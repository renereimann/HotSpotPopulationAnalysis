#!/usr/bin/env python

import argparse, os, cPickle, time
import numpy as np
from utils import HPA_analysis, BackgroundLocalWarmSpotPool, SingleSpotTrialPool, SignalSimulation, dec_range
from data_types import LocalWarmSpotExpectation
from source_count_dist import SourceCountDistEqualFluxAtEarth, SourceCountDistFIRESONG

# get arguments
parser = argparse.ArgumentParser()
parser.add_argument("--infile_signal",
                        type=str,
                        default="test_data/signal_pool.cPickle",
                        help="Path of the single spot signal pool file.")
parser.add_argument("--infile_background",
                        type=str,
                        default="test_data/background_pool.pickle",
                        help="Path of the background warm spot pool file.")
parser.add_argument("--expectation",
                        type=str,
                        default="test_data/from_poisson_test/HPA_nspot_expectation.pickle",
                        help="Path of the LocalWarmSpotExpecation file.")
parser.add_argument("--outfile",
                        type=str,
                        default="test_data/test_signal.npy",
                        help="Path where the signal simulation results should be saved.")
parser.add_argument("--log10pVal_threshold",
                    type=float,
                    required=False,
                    default=2.0,
                    help="Give the -log10(p-value) above that spots should not be considerd. Default: 2.0.")
parser.add_argument("--min_ang_dist",
                    type=float,
                    required=False,
                    default=1.0,
                    help="Give the minimal angular distance allowed between two local warm spots. Units: degrees. Default: 1.")
parser.add_argument("--n_iter",
                    type=int,
                    default=100,
                    help="Number of simulation trials that are generated. Default: 100")
parser.add_argument("--seed",
                    type=int,
                    default=None,
                    help="Random Number Seed. Default: None")
parser.add_argument("--nsrc",
                    type=int,
                    default=None,
                    help="Number of Source in population. Default: None")
parser.add_argument("--phi_inj",
                    type=float,
                    default=None,
                    help="Flux @ 1 GeV of sources at Earth. Units: 1/GeV cm^2 s. Default: None")
parser.add_argument("--infile_source_count",
                    type=str,
                    default=None,
                    help="Path of file containing a source count distribution generated by FIRESONG. Default: None")
parser.add_argument("--density",
                    type=float,
                    default=None,
                    help="Density of sources. Scales the number of sources for source count distributions generated with FIRESONG. Default: None")
args = parser.parse_args()

print "Run", os.path.realpath(__file__)
print "Use arguments:", args
print

# setup all the different pieces
RNG = np.random.RandomState(args.seed)
seed_bgd, seed_sig, seed_source_count = RNG.randint(0, np.iinfo(np.uint32).max, size=3)

print("Load expectation ...")
expect = LocalWarmSpotExpectation(load_path=args.expectation)

print("Load background pool ...")
bgd_pool = BackgroundLocalWarmSpotPool()
bgd_pool.load(args.infile_background, seed=seed_bgd)

print("Load signal pool ...")
sig_pool = SingleSpotTrialPool()
sig_pool.load(args.infile_signal, seed=seed_sig)

print("Setup source count distribution ...")
source_count = None
if args.phi_inj is not None and args.nsrc is not None:
    source_count = SourceCountDistEqualFluxAtEarth(phi_inj=args.phi_inj, n_sources=args.nsrc)
elif args.infile_source_count is not None:
    source_count = SourceCountDistFIRESONG(infile=args.infile_source_count, density=None)
else:
    raise NotImplementedError("You need to either give --phi_inj and --nsrc or --infile_source_cout (and --density) to specify a source count distribution.")

print("Setup simulation ...")
sim = SignalSimulation( seed=None,
                        background_pool=bgd_pool,
                        single_spot_pool=sig_pool,
                        source_count_dist=source_count,
                        min_ang_dist=args.min_ang_dist,
                        dec_range=dec_range,
                        log10pVal_threshold=args.log10pVal_threshold)

print("Setup analysis ...")
analysis = HPA_analysis(expect)

### prepare output
out = []
dtype = [("n_inj", np.int), ("maxLog10P", np.float), ("HPA_TS", np.float), ("pVal", np.float), ("count", np.int), ("exp", np.float)]

#### start generating stuff
print("Start generating %d trials ..."%args.n_iter)
t0 = time.time()
while len(out) < args.n_iter:
    data, n_tot_inj = sim.get_pseudo_experiment()
    pseudo_result = analysis.best_fit(data)
    out.append(np.array((n_tot_inj, np.max(data)) + pseudo_result.tolist(), dtype=dtype))
out = np.concatenate([out])
print("... done. Needed %f sec"%(time.time()-t0))

# double check that there are no nan pvalues
m = np.isfinite(out["HPA_TS"])
if np.any(~m):
    print("Found infinite HPA_TS: {0:d} of {1:d}".format(np.count_nonzero(~m), len(m)))
out = out[m]

print out[:10]
print "..."
print out[-10:]

print("Save results")
np.save(args.outfile, out)
